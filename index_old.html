<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Trade With A Monkey</title>
	<script type="text/javascript" src="js/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            background-color: #E8EAE9;
        }
        canvas {
           display : block;
           margin : auto;
        }
        p {
           position: absolute;
           margin-top : 605px;
            left: 48%;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });
//  Load google webfont
WebFontConfig = {

    //  'active' means all requested fonts have finished loading
    //  We set a 1 second delay before calling 'createText'.
    //  For some reason if we don't the browser cannot render the text the first time it's created.
    active: function() { game.time.events.add(Phaser.Timer.SECOND, createText, this); },
    
    //  The Google Fonts we want to load (specify as many as you like in the array)
    google: {
        families: ['Montserrat::latin']
    }
    

};
(function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
})(); 
    

    
//graph vars
var last_tick = 27;
var nb_display_tick = 27;
var first_tick;
var all_ticks;
var all_ticks_short;
var all_ticks_short;
    
//player vars
var initial_capital = 100;
var OpenPositions;
var ClosedPositions;
var level;
var capital;
var closed_pos;
var capital_minl;
var capital_maxl;
var profit_factor;
    
//Init Game Vars
var game_mode;
var key_list = ['A','B','C','D','E'];

//labels
var level_lib 
var capital_lib 
var closed_pos_lib 
var capital_min_max_lib
var profit_factor_lib
var last_tick_lib

//Fonts
var tick_lib_font ="15px Montserrat";
var tick_lib_x = 707;

//Preload game images
function preload() {
    game.load.image('instructions', 'assets/Instructions.png'); //Instructions
    game.load.image('start', 'assets/start.png'); //Start button
    
    game.load.image('background', 'assets/bg.png'); //Game background
    game.load.image('board', 'assets/board.png'); //Graph background board
    game.load.image('button', 'assets/bouton.png'); //close position button
    
    game.load.image('game_over', 'assets/GameOver.png'); //Game over board
    game.load.image('restart', 'assets/restart.png'); //Restart button

    
    //  Load the Google WebFont Loader script
    game.load.script('webfont', '//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js');
}

//Create game
function create() {
    /*
    Initiate vars
    */
    //graph vars
    first_tick = 1000;
    all_ticks = [first_tick];
    all_ticks_short = [];
    vall_ticks_short = [];
    
    //player vars
    OpenPositions = [];
    ClosedPositions = [];
    level = 1;
    capital = initial_capital;
    closed_pos = 0;
    capital_min = initial_capital;
    capital_max = initial_capital;
    profit_factor = 0;
    
    //game vars
    game_mode = 'instructions';
    //Init game with instruction screeen
    game.add.sprite(0, 0, 'background');
    
    //Init timer to update graph every second
    game.time.events.loop(Phaser.Timer.SECOND, updateTick, this);

    for (i = 0; i < 10000 ; i++){
        var rand_tick = (Math.floor((Math.random() * 20) + 1) - 10);
        //alert (rand_tick+'/'+all_ticks[all_ticks.length-1]+'/'+i);
        rand_tick += all_ticks[all_ticks.length-1];
        all_ticks.push(rand_tick);
        
    }
}
 
    
function update() {
    game.destroy
    /*
    
    DISPLAY GAME
    
    */
    if (game_mode == 'play'){

        //update score before displaying it
        updateGraph()
        //display user level/score etc.
        level_lib = game.add.text(150, 523, level, { font: "60px Montserrat", fill: "#d54f58" });
        capital_lib = game.add.text(245, 523, capital, { font: "60px Montserrat", fill: "#d54f58" });

        closed_pos_lib = game.add.text(710, 515, closed_pos, { font: "20px Montserrat", fill: "#d54f58" });
        capital_min_max_lib = game.add.text(710, 541, capital_min + '/' + capital_max, { font: "20px Montserrat", fill: "#d54f58" });
        profit_factor_lib = game.add.text(710, 567, profit_factor.toFixed(2), { font: "20px Montserrat", fill: "#d54f58" });
        /*
        
        CREATE BUTTONS TO CLOSE POSITIONS
        
        */
        var button_height = 460;
        var bu = {};
        var bu_all;
        var ongoing_score = 0;
        //one button to close all position if multiple positions are opened
        if (OpenPositions.length >= 1){
            bu_all = game.add.button(650, button_height, 'button');
            bu_all.events.onInputDown.add(closePositions, {key: 'ALL'});
            bu_all.width = 50;
            bu_all.height = 50;
            game.add.text(650+7, button_height+10, 'Close\n all' , { font: "12px Montserrat", fill: "#000", align: "center"});   
        }

        //create one button per open position
        for (i = 0; i < OpenPositions.length; i++){
            bu[i] = game.add.button(650 - ((i+1) * 50), button_height, 'button');
            bu[i].events.onInputDown.add(closePositions, {key: OpenPositions[i]['CHAR']});
            bu[i].width = 50;
            bu[i].height = 50;
            game.add.text(659 - ((i+1) * 50), button_height+2, OpenPositions[i]['CHAR'] , { font: "40px Montserrat", fill: "#000" });
            
            ongoing_score += getResult(OpenPositions[i]['DIR'], OpenPositions[i]['OPEN_TICK'], OpenPositions[i]['NB_LOTS']);
        }
        if (ongoing_score + capital <= 0){
            game_mode = 'game_over';
        }
    }
    else if (game_mode == 'game_over'){
        game.add.sprite(0, 0, 'game_over');
        level_lib = game.add.text(350, 283, level, { font: "47px Montserrat", fill: "#d54f58" });
        capital_lib = game.add.text(350, 340, 0, { font: "47px Montserrat", fill: "#d54f58" });

        closed_pos_lib = game.add.text(350,400, closed_pos, { font: "20px Montserrat", fill: "#d54f58" });
        capital_min_max_lib = game.add.text(350, 421, capital_min + '/' + capital_max, { font: "20px Montserrat", fill: "#d54f58" });
        profit_factor_lib = game.add.text(350, 445, profit_factor.toFixed(2), { font: "20px Montserrat", fill: "#d54f58" });
        
        var restart_button = game.add.button(220, 475, 'restart');
        restart_button.events.onInputDown.add(create);
    }
    else if (game_mode == 'instructions'){
        game.add.sprite(0, 0, 'instructions');
        var play_button = game.add.button(270, 500, 'start');
        play_button.events.onInputDown.add(start_game);
    }
}

function start_game(){
    game_mode = 'play';
    update()
}
    
function updateTick(){
    /*
    UPDATE LAST TICK
    */
    last_tick ++;
    /*
    UPDATE ongoing positions and graph
    */
    if (game_mode == 'play'){
        createNewPositions()
        updateGraph()
    }
    
}
/*
UPDATE GRAPH & DISPLAY POSITIONS
*/
function updateGraph() {
    /*
    UPDATE GRAPH
    */
    //display graph bg image
    game.add.sprite(4, 120, 'board');
    var g = game.add.graphics(0, 0);
    
    //get last 27 ticks
    var all_ticks_short = all_ticks.slice(last_tick-nb_display_tick,last_tick);
    //alert (all_ticks_short.length);
    //get min/max and range of the last 27th (to calculate points positions)
    var tick_max = Math.max.apply(Math, all_ticks_short);
    var tick_min = Math.min.apply(Math, all_ticks_short);
    var range = tick_max - tick_min;
    //parse all ticks and display them on graph
    for (i = 0 ; i < all_ticks_short.length; i++) {
        //alert (all_ticks_short[i]+'/'+i);
        //y positions between 127px  and 447px from the top
        var tick_pos_y =  455 + (317/range)*(tick_min - all_ticks_short[i]);
        //x position: each tick separated by 25px (begin at 30px from left)
        var tick_pos_x = 30 + (25* i);

        //draw a circle for current tick
        g.beginFill(0xcc9900, 1);
        g.drawCircle(tick_pos_x, tick_pos_y, 6);

        //draw a line between this tick and the previous one
        if (i !== 0){
            g.lineStyle(2, 0xcc9900, 1);
            g.moveTo(prev_tick_pos_x, prev_tick_pos_y);
            g.lineTo(tick_pos_x, tick_pos_y);
        }
        //keep in memory this tick position
        var prev_tick_pos_y = tick_pos_y;
        var prev_tick_pos_x = tick_pos_x;
        
        if (i == nb_display_tick-1){
            //update current tick label
            game.add.text(709, (tick_pos_y -10), all_ticks_short[i],  { font: "15px Montserrat", fill: '#E8EAE9', backgroundColor: '#113F59' });
            }


        }//end for
    /*
    DISPLAY POSITIONS
    */
    //for every position, display it on the graph
    for (i = 0 ; i < OpenPositions.length; i++){
        //calculate position line position
        var pos_y =  455 + (317/range)*(tick_min - OpenPositions[i]['OPEN_TICK']);
        if (pos_y > 455){
            pos_y = 455;
        }
        else if (pos_y < 138){
            pos_y = 138;
        }
        //get line color and gain potentiel depending of the position direction BUY/SELL
        var gain_potentiel = getResult(OpenPositions[i]['DIR'], OpenPositions[i]['OPEN_TICK'], OpenPositions[i]['NB_LOTS']);
        if (OpenPositions[i]['DIR'] == 'BUY'){
            var line_color = '0x33CC00';
            var lib_color = '#33CC00'; 
        }
        else if (OpenPositions[i]['DIR'] == 'SELL'){
            var line_color = '0xd54f58';
            var lib_color = '#d54f58';
        }

        //Draw position line
        g.lineStyle(2, line_color, 1);  
        g.moveTo(18, pos_y);
        g.lineTo(690, pos_y);
        //Display position open & gain potentiel
        game.add.text(707, pos_y-12, OpenPositions[i]['OPEN_TICK'] + '('+gain_potentiel+')',  { font: "15px Montserrat", fill: '#000', backgroundColor: lib_color});

        //draw circles on line to display NB_LOT and closing key
        g.beginFill(line_color, 1);
        g.drawCircle(590, pos_y, 23);
        game.add.text(587, pos_y-7, OpenPositions[i]['CHAR'],  { font: "10px Montserrat", fill: '#000' , backgroundColor: lib_color} );
        g.drawCircle(660, pos_y, 23);
        game.add.text(658, pos_y-7, OpenPositions[i]['NB_LOTS'],  { font: "10px Montserrat", fill: '#000' , backgroundColor: lib_color} );
    }
}


/*
GET RESULT OF A POSITION
*/    
function getResult(dir, open, nblots) {
        if (dir == 'BUY'){
            return ((all_ticks[last_tick-1] - 0.5) - (open + 0.5)) * nblots;
            //return all_ticks[last_tick] 
        }
        else if (dir == 'SELL'){
            return ((open - 0.5)- (all_ticks[last_tick-1] + 0.5) ) * nblots;
            //return all_ticks[last_tick]
        }  
}
/*

Create new positions

*/
function createNewPositions() {
    if (OpenPositions.length * 2  < level){
        var open_new = Math.floor((Math.random() * 5) + 1);
        var pos_key = Math.floor((Math.random() * 5) + 1)-1;
        var pos_nb_lots = Math.floor((Math.random() * level) + 1);
        pos_key = key_list[pos_key];
        if (open_new == 1){
            var position_dir = Math.floor((Math.random() * 2) + 1);
            if (position_dir == 1){
                var new_pos_dir = 'BUY';
            }
            else{
                var new_pos_dir = 'SELL';
            }
            var new_position = {
                'OPEN_TICK': all_ticks[last_tick],
                'DIR': new_pos_dir,
                'CHAR': pos_key,
                'NB_LOTS': pos_nb_lots,
            }
            OpenPositions.push(new_position);
            //alert ('new pos created'+OpenPositions.length)
        }
    }
}

/*

Close positions

*/
function closePositions(key) {
    //alert(this.key);
    for (i = 0; i < OpenPositions.length; i++){
        if (OpenPositions[i]['CHAR'] == this.key || this.key == 'ALL'){
            //calculate position rst
            var position_rst = getResult(OpenPositions[i]['DIR'], OpenPositions[i]['OPEN_TICK'], OpenPositions[i]['NB_LOTS']);
            //add closed position to list of closed positions
            var closed_pos = {
                'OPEN_TICK': OpenPositions[i]['OPEN_TICK'],
                'DIR': OpenPositions[i]['DIR'],
                'CHAR': OpenPositions[i]['CHAR'],
                'NB_LOTS': OpenPositions[i]['NB_LOTS'],
                'CLOSE_TICK': all_ticks[last_tick],
                'RST':position_rst,
            }
            ClosedPositions.push(closed_pos);
            OpenPositions.splice(i, 1);//remove position from list of open positions
            //alert('close position');
        }
    }
    updateGraph();
    updateScore();

}

/*

Update score

*/
function updateScore() {
    capital = initial_capital;
    closed_pos = ClosedPositions.length;
    capital_min = capital;
    capital_max = capital;
    var sum_gains = 0;
    var sum_losses = 0;
    profit_factor = 0;
    //alert ('Update score with '+ClosedPositions.length+' closed positons.');
    if (ClosedPositions.length > 0){
        for (i = 0; i < ClosedPositions.length; i++){
            //alert ('Position ' + i + ' / ' + ClosedPositions[i]['RST'])
            capital += ClosedPositions[i]['RST'];
            //update capital min/max
            if (capital < capital_min){
                capital_min = capital;
            }
            else if (capital > capital_max){
                capital_max = capital;
            }

            //update sum gains and sum losses
            if (ClosedPositions[i]['RST'] > 0){
                sum_gains += ClosedPositions[i]['RST'];
            }
            else if (ClosedPositions[i]['RST'] < 0){
                sum_losses += ClosedPositions[i]['RST'];
            }
        }
    }
    //update profit factor
    if (sum_losses < 0){
        profit_factor = sum_gains / Math.abs(sum_losses);
    }
    //update level every 50 EUR
    level  = Math.floor((capital_max - 100) / 50)+1;
    //level = 3;
}
</script>
<p><a href="https://github.com/cimourdain/Trade-with-a-Monkey">Source</a></p>
</body>
</html>